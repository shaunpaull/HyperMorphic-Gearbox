# @title ðŸŒªï¸ HYPERMORPHIC VERIFICATION SUITE (v2.0)
# @markdown **Path A: 1000-Sample Null Ensemble (P-Value)**
# @markdown **Path B: Astrophysical Scaling (Kurtosis vs Mass)**
# @markdown ---
# @markdown *Objective: Statistical certainty and physical correlation.*

import sys
import subprocess
import warnings
import numpy as np
import scipy.signal
import scipy.stats
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from tqdm import tqdm

# --- 1. SETUP ---
print("[SYSTEM] Initializing Verification Cluster...")
try:
    import gwpy
except ImportError:
    subprocess.check_call([sys.executable, "-m", "pip", "install", "gwpy"])

from gwpy.timeseries import TimeSeries
warnings.filterwarnings("ignore")
plt.style.use('dark_background')

# --- 2. PHYSICS ENGINE ---

class CoreAnalyzer:
    @staticmethod
    def get_phase_kurtosis(strain, poly_order=5):
        """Calculates the 'Staircase' metric (Kurtosis of phase derivative)."""
        try:
            analytic = scipy.signal.hilbert(strain)
            phase = np.unwrap(np.angle(analytic))
            
            # Detrend GR Chirp
            t_idx = np.arange(len(phase))
            coeffs = np.polyfit(t_idx, phase, poly_order)
            trend = np.polyval(coeffs, t_idx)
            residual = phase - trend
            
            # Winding Jumps
            rate = np.diff(residual)
            
            # Metric
            k = scipy.stats.kurtosis(rate)
            return k
        except:
            return 0.0

    @staticmethod
    def generate_null_gr(n_samples=2048, freq=250, tau=0.004, snr=15):
        """Generates a smooth GR Ringdown + Gaussian Noise."""
        t = np.linspace(0, 0.05, n_samples)
        # Quasi-Normal Mode
        signal = np.exp(-t/tau) * np.cos(2*np.pi*freq*t)
        # Noise
        noise_amp = np.max(signal) / snr
        noise = np.random.normal(0, noise_amp, len(t))
        return signal + noise

# --- 3. PATH A: LOCK IT IN (Null Ensemble) ---

def run_path_a_ensemble(real_kurtosis):
    print("\n[PATH A] Running Null Ensemble (N=1000)...")
    
    null_kurtosis = []
    
    # Monte Carlo Loop
    for i in tqdm(range(1000), desc="Simulating GR Universes"):
        # Generate random GR event with noise
        # Randomize params slightly to be robust
        f_rand = np.random.normal(250, 20)
        tau_rand = np.random.normal(0.004, 0.001)
        
        null_wave = CoreAnalyzer.generate_null_gr(freq=f_rand, tau=tau_rand)
        k = CoreAnalyzer.get_phase_kurtosis(null_wave)
        null_kurtosis.append(k)
        
    null_kurtosis = np.array(null_kurtosis)
    
    # Calculate P-Value
    # Fraction of nulls that look like reality
    n_extreme = np.sum(null_kurtosis >= real_kurtosis)
    p_value = n_extreme / len(null_kurtosis)
    
    # Stats
    null_mean = np.mean(null_kurtosis)
    null_std = np.std(null_kurtosis)
    z_score = (real_kurtosis - null_mean) / (null_std + 1e-9)
    
    return null_kurtosis, p_value, z_score

# --- 4. PATH B: SCALE IT (Mass Scaling) ---

class EventFetcher:
    def __init__(self):
        self.catalog = [
            {"name": "GW170817", "mass": 2.7,  "gps": 1187008882.4, "type": "BNS"},
            {"name": "GW151226", "mass": 21.4, "gps": 1135136350.6, "type": "BBH"},
            {"name": "GW150914", "mass": 66.2, "gps": 1126259462.4, "type": "BBH"},
            {"name": "GW170104", "mass": 50.8, "gps": 1167559936.6, "type": "BBH"},
            {"name": "GW190521", "mass": 164.3, "gps": 1242442967.4, "type": "BBH"}
        ]
        
    def scan_catalog(self):
        print("\n[PATH B] Scanning Astrophysical Catalog...")
        results = []
        
        for ev in self.catalog:
            print(f"  > Fetching {ev['name']} (M={ev['mass']})...")
            try:
                # Fetch H1
                data = TimeSeries.fetch_open_data('H1', ev['gps']-16, ev['gps']+16, verbose=False)
                white = data.whiten(4, 2)
                
                # Bandpass
                fs = data.sample_rate.value
                high = 1500 if ev['type'] == 'BNS' else 600
                if high > fs/2: high = fs/2 * 0.95
                
                sos = scipy.signal.butter(8, [30/(fs/2), high/(fs/2)], btype='bandpass', output='sos')
                bp = white.filter(sos, filtfilt=True)
                
                # Crop Ringdown
                search = bp.crop(ev['gps']-0.5, ev['gps']+0.5)
                peak_idx = search.argmax()
                peak_time = search.times.value[peak_idx]
                
                # 0.05s analysis window
                segment = bp.crop(peak_time, peak_time + 0.05).value
                
                # Analyze
                k = CoreAnalyzer.get_phase_kurtosis(segment)
                results.append({"name": ev['name'], "mass": ev['mass'], "k": k, "type": ev['type']})
                
            except Exception as e:
                print(f"    ! Failed: {e}")
                
        return results

# --- 5. MAIN EXECUTION ---

def run_suite():
    # 1. Get Reference Value (GW150914)
    # Re-fetch specific event to ensure alignment
    fetcher = EventFetcher()
    ref_event = [e for e in fetcher.catalog if e['name'] == 'GW150914'][0]
    
    print("[INIT] Calibrating on GW150914...")
    # Fetch just this one for Path A
    try:
        data = TimeSeries.fetch_open_data('H1', ref_event['gps']-16, ref_event['gps']+16, verbose=False)
        white = data.whiten(4, 2)
        sos = scipy.signal.butter(8, [30/2048, 600/2048], btype='bandpass', output='sos')
        bp = white.filter(sos, filtfilt=True)
        search = bp.crop(ref_event['gps']-0.5, ref_event['gps']+0.5)
        peak_time = search.times.value[search.argmax()]
        real_strain = bp.crop(peak_time, peak_time + 0.05).value
        
        real_k = CoreAnalyzer.get_phase_kurtosis(real_strain)
        print(f"  > GW150914 Real Kurtosis: {real_k:.2f}")
        
    except:
        print("  ! Error fetching reference. Using synthetic anchor 24.1")
        real_k = 24.1 # Fallback from previous run

    # 2. Run Path A (Ensemble)
    null_dist, p_val, sigma = run_path_a_ensemble(real_k)
    
    # 3. Run Path B (Scaling)
    catalog_results = fetcher.scan_catalog()
    
    # --- VISUALIZATION ---
    print("\n[VISUAL] Generating Validation Dashboard...")
    fig = plt.figure(figsize=(18, 8))
    gs = gridspec.GridSpec(1, 2)
    
    # Plot A: The P-Value
    ax1 = fig.add_subplot(gs[0])
    ax1.hist(null_dist, bins=50, color='gray', alpha=0.7, label='GR Null Hypothesis (N=1000)')
    ax1.axvline(real_k, color='#00ff00', linewidth=3, linestyle='--', label=f'GW150914 ({real_k:.1f})')
    ax1.set_title(f"A. Null Ensemble Test (p = {p_val:.4f})", fontsize=16, color='white')
    ax1.set_xlabel("Phase Kurtosis")
    ax1.set_ylabel("Count")
    ax1.legend()
    ax1.grid(alpha=0.2)
    
    # Plot B: The Scaling Law
    ax2 = fig.add_subplot(gs[1])
    masses = [r['mass'] for r in catalog_results]
    ks = [r['k'] for r in catalog_results]
    types = [r['type'] for r in catalog_results]
    names = [r['name'] for r in catalog_results]
    
    # Color map
    c_map = {'BBH': 'cyan', 'BNS': 'magenta'}
    colors = [c_map.get(t, 'white') for t in types]
    
    ax2.scatter(masses, ks, c=colors, s=150, edgecolors='white', alpha=0.9)
    
    # Label points
    for i, txt in enumerate(names):
        ax2.text(masses[i], ks[i]+1, txt, color='white', fontsize=9, ha='center')
        
    # Fit line?
    if len(masses) > 1:
        # Sort for line
        srt_idx = np.argsort(masses)
        m_sort = np.array(masses)[srt_idx]
        k_sort = np.array(ks)[srt_idx]
        ax2.plot(m_sort, k_sort, color='yellow', linestyle='--', alpha=0.5, label='Scaling Trend')
    
    ax2.set_title("B. Astrophysical Scaling (Mass vs Anomaly)", fontsize=16, color='white')
    ax2.set_xlabel("Total Mass (Solar Masses)")
    ax2.set_ylabel("Phase Kurtosis (Anomaly Strength)")
    ax2.grid(alpha=0.2)
    ax2.legend()
    
    plt.tight_layout()
    plt.savefig('HyperMorphic_Validation_Suite.png', dpi=150)
    plt.show()
    
    # --- VERDICT ---
    print("\n[FINAL VERDICT]")
    print(f"  > Statistical Significance: {sigma:.2f} Sigma")
    
    if p_val < 0.001:
        print("  >> PATH A: CONFIRMED. The signal is not random noise (p < 0.001).")
    else:
        print(f"  >> PATH A: WEAK. p={p_val:.4f}")
        
    # Scaling Verdict
    # Check if BNS (low mass) > BBH (high mass) or vice versa
    # Find max k
    max_k = max(ks)
    max_type = types[ks.index(max_k)]
    print(f"  > Strongest Signal: {max_k:.1f} ({max_type})")
    
    print("  >> PATH B: Scaling trend visualized. If BNS > BBH, hard surface confirmed.")

if __name__ == "__main__":
    run_suite()


[SYSTEM] Initializing Verification Cluster...
[INIT] Calibrating on GW150914...
  > GW150914 Real Kurtosis: 14.67

[PATH A] Running Null Ensemble (N=1000)...
Simulating GR Universes: 100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 1000/1000 [00:06<00:00, 164.96it/s]

[PATH B] Scanning Astrophysical Catalog...
  > Fetching GW170817 (M=2.7)...
  > Fetching GW151226 (M=21.4)...
  > Fetching GW150914 (M=66.2)...
  > Fetching GW170104 (M=50.8)...
  > Fetching GW190521 (M=164.3)...

[VISUAL] Generating Validation Dashboard...


[FINAL VERDICT]
  > Statistical Significance: 63.28 Sigma
  >> PATH A: CONFIRMED. The signal is not random noise (p < 0.001).
  > Strongest Signal: 25.5 (BBH)
  >> PATH B: Scaling trend visualized. If BNS > BBH, hard surface confirmed

