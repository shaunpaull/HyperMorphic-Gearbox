"""
HYPERMORPHIC CORE ENGINE (v2.0)
-------------------------------
A Deterministic, Lossless Dimensional Transfer Protocol.

This engine implements "SafeGear" logic, ensuring 100% reversibility between 
mathematical contexts (Dimensions) of arbitrary size.

Features:
1. Dynamic Modulus/Base Coupling: m(d) = sqrt(d), b(d) = log2(d).
2. Coprimality Enforcement: Auto-adjusts Base (b) to ensure GCD(b, m) == 1.
3. Fluid Data Transfer: Automatically handles Space-Time tradeoffs.
   - Expansion: High-Dimension <- Low-Dimension (Instant)
   - Compression: Low-Dimension <- High-Dimension (Temporal Unfolding)

Author: Shaun Paull / HyperMorphic Research
License: MIT
"""

import math
import time

# --- CORE LOGIC ---

class SafeGear:
    """
    The mathematical primitive that defines a Context 'Gear'.
    """
    @staticmethod
    def get_params(d):
        """
        Calculates the Modulus (m) and Base (b) for a given Dimension (d).
        Applies the 'Coprimality Patch' to guarantee a bijective map.
        """
        if d <= 0: d = 1
        
        # 1. Dynamic Modulus: The Capacity of the Gear
        m = int(math.floor(math.sqrt(d))) + 1
        
        # 2. Dynamic Base: The Winding Number
        b_raw = int(math.floor(math.log2(d))) + 1
        
        # 3. The Fix: Stability Check
        # If Base and Modulus share a factor, the gear slips (collisions occur).
        # We hunt for the nearest 'locked' base where GCD is 1.
        b_safe = b_raw
        while math.gcd(b_safe, m) != 1:
            b_safe += 1
            
        return m, b_safe

class HyperMorphicEngine:
    """
    The Transfer Protocol for moving data between Dimensions.
    """
    @staticmethod
    def encode(val, m, b):
        """Map a raw integer into the Gear's phase space."""
        return (val * b) % m

    @staticmethod
    def decode(val, m, b):
        """Recover the raw integer from the Gear's phase space."""
        # Modular Multiplicative Inverse exists because GCD(b, m) == 1
        b_inv = pow(b, -1, m)
        return (val * b_inv) % m

    @staticmethod
    def transfer(value, d_source, d_target):
        """
        Moves a value from Source Dimension to Target Dimension.
        Returns: (Mode, Data)
          - Mode 'EXPANSION': Data is a single integer.
          - Mode 'COMPRESSION': Data is a list of integers (Time-Series).
        """
        m_src, b_src = SafeGear.get_params(d_source)
        m_tgt, b_tgt = SafeGear.get_params(d_target)
        
        # 1. Extract Pure Magnitude from Source
        raw_val = HyperMorphicEngine.decode(value, m_src, b_src)
        
        # 2. Check Capacity Physics
        if m_tgt >= m_src:
            # Case A: Target is larger. Fits instantly.
            new_val = HyperMorphicEngine.encode(raw_val, m_tgt, b_tgt)
            return "EXPANSION", [new_val]
        else:
            # Case B: Target is smaller. Must unfold over time.
            # We decompose the value into base-m_tgt chunks.
            stream = []
            temp = raw_val
            
            # Handle 0 case explicitly
            if temp == 0:
                stream.append(0)
            
            while temp > 0:
                chunk = temp % m_tgt # Slices off a piece that fits
                encoded_chunk = HyperMorphicEngine.encode(chunk, m_tgt, b_tgt)
                stream.append(encoded_chunk)
                temp //= m_tgt
                
            return "COMPRESSION", stream

    @staticmethod
    def restore(packet, d_current, d_target):
        """
        Reassembles data from d_current back into d_target.
        """
        mode, stream = packet
        m_curr, b_curr = SafeGear.get_params(d_current)
        m_tgt, b_tgt = SafeGear.get_params(d_target)
        
        total_raw = 0
        
        if mode == "EXPANSION":
            raw_val = HyperMorphicEngine.decode(stream[0], m_curr, b_curr)
            total_raw = raw_val
        elif mode == "COMPRESSION":
            # Reassemble Little-Endian Stream
            power = 1
            for encoded_chunk in stream:
                chunk = HyperMorphicEngine.decode(encoded_chunk, m_curr, b_curr)
                total_raw += chunk * power
                power *= m_curr
                
        # Re-encode in target (Original) dimension
        return HyperMorphicEngine.encode(total_raw, m_tgt, b_tgt)


# --- BENCHMARKING SUITE ---

class HyperBench:
    def run_all(self):
        print("===============================================================")
        print("   HYPERMORPHIC GEARBOX (v2.0) - PERFORMANCE & INTEGRITY CHECK")
        print("===============================================================\n")
        
        self.check_stability()
        self.check_lossless_integrity()
        self.check_compression_physics()
        self.stress_test_throughput()
        
    def check_stability(self):
        print("[1] GEAR STABILITY ANALYSIS")
        print("    Scanning Dimensions 100 to 10,000 for 'Slipping Gears'...")
        
        total = 0
        adjustments = 0
        
        for d in range(100, 10001):
            total += 1
            # Calculate raw vs safe
            m = int(math.floor(math.sqrt(d))) + 1
            b_raw = int(math.floor(math.log2(d))) + 1
            b_safe = SafeGear.get_params(d)[1]
            
            if b_raw != b_safe:
                adjustments += 1
                
        rate = (adjustments / total) * 100
        print(f"    - Dimensions Scanned: {total}")
        print(f"    - Raw GCD Collisions: {adjustments}")
        print(f"    - Coprimality Patch Rate: {rate:.2f}%")
        print(f"    - Result: 100% STABLE (All gears locked via auto-adjustment).")
        print("-" * 60)

    def check_lossless_integrity(self):
        print("\n[2] DATA INTEGRITY (The 'HYPER' Test)")
        print("    Route: Source -> Small -> Source")
        
        # Test Value: Must fit within m(50000) = 224
        original_d = 50000
        original_val = 200 # Fits in 224
        
        # Encode initial state
        m, b = SafeGear.get_params(original_d)
        gear_val = HyperMorphicEngine.encode(original_val, m, b)
        
        print(f"    - Input: {original_val} (Context d={original_d}, Capacity=224)")
        
        # Round Trip: 50k -> 500 -> 50k
        mode, stream = HyperMorphicEngine.transfer(gear_val, 50000, 500)
        print(f"    - Compressed (d=500): {len(stream)} packets generated.")
        
        recovered = HyperMorphicEngine.restore((mode, stream), 500, 50000)
        
        # Decode to raw to verify
        rec_raw = HyperMorphicEngine.decode(recovered, m, b)
        
        print(f"    - Recovered: {rec_raw}")
        if rec_raw == original_val:
            print("    - STATUS: PASSED (Lossless).")
        else:
            print(f"    - STATUS: FAILED (Diff: {rec_raw - original_val})")
        print("-" * 60)

    def check_compression_physics(self):
        print("\n[3] SPACE-TIME METRICS")
        print("    Measuring Dimensional Reduction vs. Temporal Inflation.")
        print(f"    {'Source D':<10} | {'Target D':<10} | {'Space Ratio':<12} | {'Time Cost (Ticks)':<15}")
        print("    " + "-"*55)
        
        # Source 1M (m=1001). Val=950.
        val_raw_bench = 950
        src_d = 1000000 
        m_src, b_src = SafeGear.get_params(src_d)
        val_enc = HyperMorphicEngine.encode(val_raw_bench, m_src, b_src)
        
        bench_cases = [
            (src_d, 100000), 
            (src_d, 10000),  
            (src_d, 1000),
            (src_d, 100)
        ]

        for d_in, d_out in bench_cases:
            # Perform transfer
            mode, stream = HyperMorphicEngine.transfer(val_enc, d_in, d_out)
            
            dim_ratio = d_in / d_out
            time_cost = len(stream)
            
            print(f"    {d_in:<10} | {d_out:<10} | {dim_ratio:<12.1f} | {time_cost:<15}")
        print("-" * 60)

    def stress_test_throughput(self):
        print("\n[4] THROUGHPUT STRESS TEST")
        ops = 100000
        print(f"    Performing {ops} encode/decode cycles...")
        
        start = time.time()
        d = 65536
        m, b = SafeGear.get_params(d)
        
        # Loop
        for i in range(ops):
            val = i % m
            enc = (val * b) % m
            dec = (enc * pow(b, -1, m)) % m
            
        end = time.time()
        duration = end - start
        ops_per_sec = ops / duration
        
        print(f"    - Duration: {duration:.4f}s")
        print(f"    - Speed: {ops_per_sec:,.0f} Ops/Sec")
        print("===============================================================")


if __name__ == "__main__":
    bench = HyperBench()
    bench.run_all()
