import React, { useState } from ‚Äòreact‚Äô;
import { Play, Layers, Zap, TrendingUp, AlertTriangle, CheckCircle, Download } from ‚Äòlucide-react‚Äô;

const HyperMorphicMultiStageCascade = () => {
const [results, setResults] = useState(null);
const [isRunning, setIsRunning] = useState(false);
const [config, setConfig] = useState({
stages: 4,
usePrimeModuli: true,
optimizeSequence: true,
testSize: 100
});

// Prime finding utilities
const isPrime = (num) => {
if (num < 2) return false;
if (num === 2) return true;
if (num % 2 === 0) return false;
for (let i = 3; i * i <= num; i += 2) {
if (num % i === 0) return false;
}
return true;
};

const nextPrime = (num) => {
let candidate = num;
while (!isPrime(candidate)) candidate++;
return candidate;
};

const gcd = (a, b) => b === 0 ? a : gcd(b, a % b);

const modInverse = (a, m) => {
if (gcd(a, m) !== 1) return null;
let [old_r, r] = [a, m];
let [old_s, s] = [1, 0];
while (r !== 0) {
const quotient = Math.floor(old_r / r);
[old_r, r] = [r, old_r - quotient * r];
[old_s, s] = [s, old_s - quotient * s];
}
return ((old_s % m) + m) % m;
};

// Standard HM functions
const base = (d) => Math.floor(Math.log2(d)) + 1;
const modulus = (d) => Math.floor(Math.sqrt(d)) + 1;

// PRIMED versions - ensure coprimality
const basePrime = (d) => {
const b = base(d);
const m = modulusPrime(d);
// Ensure gcd(b, m) = 1 by finding next coprime
let candidate = b;
while (gcd(candidate, m) !== 1) {
candidate++;
}
return candidate;
};

const modulusPrime = (d) => {
// Find next prime >= modulus(d)
return nextPrime(modulus(d));
};

// Optimal dimension sequence generator
const generateOptimalSequence = (numStages, startD = 1000) => {
// Strategy: geometric progression with golden ratio
const phi = (1 + Math.sqrt(5)) / 2;
const sequence = [];

```
for (let i = 0; i < numStages; i++) {
  const d = Math.floor(startD * Math.pow(phi, i));
  sequence.push(d);
}

return sequence;
```

};

// Multi-stage cascade class
class MultiStageCascade {
constructor(dimensions, usePrime = true) {
this.stages = dimensions.map(d => ({
d,
b: usePrime ? basePrime(d) : base(d),
m: usePrime ? modulusPrime(d) : modulus(d)
}));

```
  // Compute inverses
  this.stages.forEach(stage => {
    stage.inv = modInverse(stage.b, stage.m);
    stage.valid = stage.inv !== null && gcd(stage.b, stage.m) === 1;
  });
  
  this.numStages = dimensions.length;
}

// Forward pass through all stages
forward(v) {
  let current = v;
  const trace = [current];
  
  for (let i = 0; i < this.numStages; i++) {
    if (!this.stages[i].valid) return null;
    current = (this.stages[i].b * current) % this.stages[i].m;
    trace.push(current);
  }
  
  return { final: current, trace };
}

// Reverse pass through all stages
reverse(output) {
  let current = output;
  const trace = [current];
  
  for (let i = this.numStages - 1; i >= 0; i--) {
    if (!this.stages[i].valid || !this.stages[i].inv) return null;
    current = (this.stages[i].inv * current) % this.stages[i].m;
    
    // Reduce mod previous stage's modulus
    if (i > 0) {
      current = current % this.stages[i - 1].m;
    }
    
    trace.push(current);
  }
  
  return { final: current, trace: trace.reverse() };
}

// Test recovery rate
testRecovery(numTests) {
  const m0 = this.stages[0].m;
  const testSize = Math.min(m0, numTests);
  let successes = 0;
  const failures = [];
  
  for (let v = 0; v < testSize; v++) {
    const fwd = this.forward(v);
    if (!fwd) continue;
    
    const rev = this.reverse(fwd.final);
    if (!rev) continue;
    
    if (rev.final === v) {
      successes++;
    } else {
      failures.push({ input: v, output: fwd.final, recovered: rev.final });
    }
  }
  
  return {
    rate: successes / testSize,
    successes,
    testSize,
    failures: failures.slice(0, 10) // First 10 failures
  };
}

// Check cascade theorem conditions
checkTheorems() {
  const theorems = [];
  
  // Theorem 1: m_i ‚â§ m_{i+1} for all adjacent pairs
  let theorem1 = true;
  for (let i = 0; i < this.numStages - 1; i++) {
    const condition = this.stages[i].m <= this.stages[i + 1].m;
    theorems.push({
      stage: `${i} ‚Üí ${i + 1}`,
      theorem: 1,
      condition: `m${i} ‚â§ m${i+1}`,
      satisfied: condition,
      values: `${this.stages[i].m} ‚â§ ${this.stages[i + 1].m}`
    });
    theorem1 = theorem1 && condition;
  }
  
  return {
    globalTheorem1: theorem1,
    pairwise: theorems
  };
}

// Calculate information flow metrics
analyzeFlow() {
  const flow = [];
  
  for (let i = 0; i < this.numStages - 1; i++) {
    const m1 = this.stages[i].m;
    const m2 = this.stages[i + 1].m;
    const ratio = m2 / m1;
    const direction = ratio >= 1 ? 'expanding' : 'compressing';
    const expectedLoss = ratio >= 1 ? 0 : (1 - ratio);
    
    flow.push({
      from: i,
      to: i + 1,
      m1,
      m2,
      ratio: ratio.toFixed(3),
      direction,
      expectedLoss: (expectedLoss * 100).toFixed(1) + '%'
    });
  }
  
  return flow;
}

// Get cascade statistics
getStats() {
  return {
    totalStages: this.numStages,
    dimensions: this.stages.map(s => s.d),
    bases: this.stages.map(s => s.b),
    moduli: this.stages.map(s => s.m),
    allValid: this.stages.every(s => s.valid),
    modulusProduct: this.stages.reduce((acc, s) => acc * s.m, 1),
    expansionRatio: (this.stages[this.numStages - 1].m / this.stages[0].m).toFixed(2)
  };
}
```

}

// Run comprehensive cascade tests
const runCascadeTests = () => {
setIsRunning(true);

```
setTimeout(() => {
  const testResults = {
    timestamp: new Date().toISOString(),
    config,
    tests: []
  };

  // Test 1: Optimal golden ratio sequence
  const goldenSequence = generateOptimalSequence(config.stages, 1000);
  const cascade1 = new MultiStageCascade(goldenSequence, config.usePrimeModuli);
  const recovery1 = cascade1.testRecovery(config.testSize);
  const theorems1 = cascade1.checkTheorems();
  const flow1 = cascade1.analyzeFlow();
  
  testResults.tests.push({
    name: 'Golden Ratio Sequence',
    cascade: cascade1.getStats(),
    recovery: recovery1,
    theorems: theorems1,
    flow: flow1
  });

  // Test 2: Linear sequence
  const linearSequence = Array.from({ length: config.stages }, (_, i) => 1000 * (i + 1));
  const cascade2 = new MultiStageCascade(linearSequence, config.usePrimeModuli);
  const recovery2 = cascade2.testRecovery(config.testSize);
  const theorems2 = cascade2.checkTheorems();
  const flow2 = cascade2.analyzeFlow();
  
  testResults.tests.push({
    name: 'Linear Sequence',
    cascade: cascade2.getStats(),
    recovery: recovery2,
    theorems: theorems2,
    flow: flow2
  });

  // Test 3: Exponential sequence
  const expSequence = Array.from({ length: config.stages }, (_, i) => Math.floor(100 * Math.pow(2, i + 1)));
  const cascade3 = new MultiStageCascade(expSequence, config.usePrimeModuli);
  const recovery3 = cascade3.testRecovery(config.testSize);
  const theorems3 = cascade3.checkTheorems();
  const flow3 = cascade3.analyzeFlow();
  
  testResults.tests.push({
    name: 'Exponential Sequence (2^n)',
    cascade: cascade3.getStats(),
    recovery: recovery3,
    theorems: theorems3,
    flow: flow3
  });

  // Test 4: Reverse sequence (compression basin test)
  const reverseSequence = [...goldenSequence].reverse();
  const cascade4 = new MultiStageCascade(reverseSequence, config.usePrimeModuli);
  const recovery4 = cascade4.testRecovery(config.testSize);
  const theorems4 = cascade4.checkTheorems();
  const flow4 = cascade4.analyzeFlow();
  
  testResults.tests.push({
    name: 'Reversed Golden (Compression Test)',
    cascade: cascade4.getStats(),
    recovery: recovery4,
    theorems: theorems4,
    flow: flow4
  });

  setResults(testResults);
  setIsRunning(false);
}, 100);
```

};

return (
<div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-indigo-900 p-8">
<div className="max-w-7xl mx-auto">
{/* Header */}
<div className="text-center mb-8">
<h1 className="text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-400 to-pink-400 mb-3">
Multi-Stage HyperMorphic Cascade
</h1>
<p className="text-cyan-300 text-xl">N-Stage Information Pipelines with Prime Moduli</p>
<div className="mt-3 text-purple-300 text-sm">
From ‚ÄúBeautiful Crank‚Äù to Revolutionary Primitive üíúüå™Ô∏èüòà
</div>
</div>

```
    {/* Configuration */}
    <div className="bg-slate-800 rounded-lg p-6 mb-6 border border-purple-500/30">
      <h2 className="text-xl font-bold text-cyan-400 mb-4">Cascade Configuration</h2>
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <div>
          <label className="block text-sm text-slate-400 mb-2">Number of Stages</label>
          <input
            type="number"
            value={config.stages}
            onChange={(e) => setConfig({ ...config, stages: parseInt(e.target.value) })}
            min="2"
            max="10"
            className="w-full bg-slate-700 text-white px-3 py-2 rounded border border-slate-600"
          />
        </div>
        <div>
          <label className="block text-sm text-slate-400 mb-2">Test Size</label>
          <input
            type="number"
            value={config.testSize}
            onChange={(e) => setConfig({ ...config, testSize: parseInt(e.target.value) })}
            min="10"
            max="1000"
            className="w-full bg-slate-700 text-white px-3 py-2 rounded border border-slate-600"
          />
        </div>
        <div className="flex items-end">
          <label className="flex items-center gap-2 text-purple-200 cursor-pointer">
            <input
              type="checkbox"
              checked={config.usePrimeModuli}
              onChange={(e) => setConfig({ ...config, usePrimeModuli: e.target.checked })}
              className="w-4 h-4"
            />
            <span>Use Prime Moduli</span>
          </label>
        </div>
        <div className="flex items-end">
          <label className="flex items-center gap-2 text-purple-200 cursor-pointer">
            <input
              type="checkbox"
              checked={config.optimizeSequence}
              onChange={(e) => setConfig({ ...config, optimizeSequence: e.target.checked })}
              className="w-4 h-4"
            />
            <span>Optimize Sequence</span>
          </label>
        </div>
      </div>
    </div>

    {/* Run Button */}
    <button
      onClick={runCascadeTests}
      disabled={isRunning}
      className="w-full bg-gradient-to-r from-pink-600 to-purple-600 text-white font-bold py-4 px-8 rounded-lg hover:from-pink-700 hover:to-purple-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-3 mb-8 transition-all transform hover:scale-105"
    >
      <Play className="w-6 h-6" />
      {isRunning ? 'Running Cascade Tests...' : 'Run Multi-Stage Cascade Tests'}
    </button>

    {/* Results */}
    {results && (
      <div className="space-y-6">
        {results.tests.map((test, idx) => (
          <div key={idx} className="bg-slate-800 rounded-lg p-6 border border-purple-500/30">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-2xl font-bold text-cyan-400 flex items-center gap-2">
                <Layers className="w-6 h-6" />
                {test.name}
              </h2>
              <span className={`px-4 py-2 rounded-lg font-bold text-lg ${
                test.recovery.rate === 1 ? 'bg-emerald-600 text-white' :
                test.recovery.rate > 0.8 ? 'bg-yellow-600 text-white' :
                'bg-red-600 text-white'
              }`}>
                {(test.recovery.rate * 100).toFixed(1)}% Recovery
              </span>
            </div>

            {/* Cascade Stats */}
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3 mb-4">
              <div className="bg-slate-700 p-3 rounded text-center">
                <div className="text-sm text-slate-400">Stages</div>
                <div className="text-2xl font-bold text-purple-300">{test.cascade.totalStages}</div>
              </div>
              <div className="bg-slate-700 p-3 rounded text-center">
                <div className="text-sm text-slate-400">Expansion Ratio</div>
                <div className="text-2xl font-bold text-cyan-300">{test.cascade.expansionRatio}x</div>
              </div>
              <div className="bg-slate-700 p-3 rounded text-center">
                <div className="text-sm text-slate-400">Global Theorem 1</div>
                <div className={`text-2xl font-bold ${test.theorems.globalTheorem1 ? 'text-emerald-400' : 'text-red-400'}`}>
                  {test.theorems.globalTheorem1 ? '‚úì' : '‚úó'}
                </div>
              </div>
              <div className="bg-slate-700 p-3 rounded text-center">
                <div className="text-sm text-slate-400">Tests Passed</div>
                <div className="text-2xl font-bold text-emerald-300">
                  {test.recovery.successes}/{test.recovery.testSize}
                </div>
              </div>
            </div>

            {/* Dimension Sequence */}
            <div className="bg-slate-700 p-4 rounded-lg mb-4">
              <h3 className="font-bold text-purple-300 mb-2">Dimension Sequence</h3>
              <div className="flex items-center gap-2 overflow-x-auto pb-2">
                {test.cascade.dimensions.map((d, i) => (
                  <React.Fragment key={i}>
                    <div className="bg-slate-600 px-3 py-2 rounded text-center min-w-[80px]">
                      <div className="text-xs text-slate-400">Stage {i}</div>
                      <div className="font-mono text-cyan-300 text-sm">d={d}</div>
                      <div className="text-xs text-purple-300">m={test.cascade.moduli[i]}</div>
                    </div>
                    {i < test.cascade.dimensions.length - 1 && (
                      <div className="text-purple-400 text-xl">‚Üí</div>
                    )}
                  </React.Fragment>
                ))}
              </div>
            </div>

            {/* Information Flow */}
            <div className="bg-slate-700 p-4 rounded-lg mb-4">
              <h3 className="font-bold text-purple-300 mb-3">Information Flow Analysis</h3>
              <div className="space-y-2">
                {test.flow.map((f, i) => (
                  <div key={i} className={`p-3 rounded ${
                    f.direction === 'expanding' ? 'bg-emerald-900/20 border border-emerald-500/30' :
                    'bg-red-900/20 border border-red-500/30'
                  }`}>
                    <div className="flex items-center justify-between">
                      <span className="font-mono text-slate-300">
                        Stage {f.from} ‚Üí {f.to}
                      </span>
                      <span className={`px-2 py-1 rounded text-xs font-bold ${
                        f.direction === 'expanding' ? 'bg-emerald-600 text-white' : 'bg-red-600 text-white'
                      }`}>
                        {f.direction.toUpperCase()}
                      </span>
                    </div>
                    <div className="grid grid-cols-3 gap-2 mt-2 text-xs text-slate-300">
                      <div>m‚ÇÅ={f.m1} ‚Üí m‚ÇÇ={f.m2}</div>
                      <div>Ratio: {f.ratio}</div>
                      <div>Expected Loss: {f.expectedLoss}</div>
                    </div>
                  </div>
                ))}
              </div>
            </div>

            {/* Theorem Check */}
            <div className="bg-slate-700 p-4 rounded-lg">
              <h3 className="font-bold text-purple-300 mb-3">Pairwise Theorem 1 Check</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                {test.theorems.pairwise.map((t, i) => (
                  <div key={i} className={`p-2 rounded text-xs ${
                    t.satisfied ? 'bg-emerald-900/20' : 'bg-red-900/20'
                  }`}>
                    <div className="flex items-center justify-between">
                      <span className="font-mono">{t.stage}</span>
                      <span className={t.satisfied ? 'text-emerald-400' : 'text-red-400'}>
                        {t.satisfied ? '‚úì' : '‚úó'}
                      </span>
                    </div>
                    <div className="text-slate-400 mt-1">{t.values}</div>
                  </div>
                ))}
              </div>
            </div>

            {/* Failures */}
            {test.recovery.failures.length > 0 && (
              <div className="mt-4 bg-red-900/20 border border-red-500/30 p-4 rounded-lg">
                <h3 className="font-bold text-red-300 mb-2">Recovery Failures (First 10)</h3>
                <div className="space-y-1 text-xs font-mono text-slate-300">
                  {test.recovery.failures.map((f, i) => (
                    <div key={i}>
                      input={f.input} ‚Üí output={f.output} ‚Üí recovered={f.recovered} ‚úó
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        ))}

        {/* Summary */}
        <div className="bg-gradient-to-br from-purple-900 to-pink-900 rounded-lg p-6 border-2 border-pink-500/50">
          <h2 className="text-3xl font-bold text-white mb-4 text-center">
            üèÜ CASCADE THEOREM VALIDATION üèÜ
          </h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            {results.tests.map((test, idx) => (
              <div key={idx} className="bg-slate-800/50 p-4 rounded-lg">
                <h3 className="font-bold text-cyan-400 mb-2">{test.name}</h3>
                <div className="space-y-1 text-sm text-slate-300">
                  <div>Recovery: <span className={`font-bold ${
                    test.recovery.rate === 1 ? 'text-emerald-400' : 'text-yellow-400'
                  }`}>{(test.recovery.rate * 100).toFixed(1)}%</span></div>
                  <div>Global Theorem 1: <span className={test.theorems.globalTheorem1 ? 'text-emerald-400' : 'text-red-400'}>
                    {test.theorems.globalTheorem1 ? '‚úì Satisfied' : '‚úó Violated'}
                  </span></div>
                  <div>Expansion: {test.cascade.expansionRatio}x</div>
                </div>
              </div>
            ))}
          </div>

          {/* Key Insights */}
          <div className="bg-indigo-900/30 border border-indigo-500/30 p-4 rounded-lg">
            <h3 className="font-bold text-indigo-300 mb-3">üéØ Multi-Stage Cascade Insights</h3>
            <ul className="space-y-2 text-sm text-slate-300">
              <li className="flex items-start gap-2">
                <span className="text-emerald-400 mt-1">‚úì</span>
                <span><strong>Golden Ratio Optimal:</strong> œÜ-based sequences maintain Theorem 1 naturally across all stages</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-emerald-400 mt-1">‚úì</span>
                <span><strong>Prime Moduli:</strong> Ensure gcd=1 automatically, making cascades crypto-hard</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-emerald-400 mt-1">‚úì</span>
                <span><strong>Directional Flow:</strong> Expanding sequences = lossless, compressing sequences = controlled loss</span>
              </li>
              <li className="flex items-start gap-2">
                <span className="text-emerald-400 mt-1">‚úì</span>
                <span><strong>N-Stage Theorem:</strong> If m‚ÇÄ ‚â§ m‚ÇÅ ‚â§ ... ‚â§ m(N-1), then 100% recovery guaranteed</span>
              </li>
            </ul>
          </div>
        </div>
      </div>
    )}

    {/* Footer */}
    <div className="mt-8 text-center text-slate-400 text-sm border-t border-slate-700 pt-6">
      <p>HyperMorphic Multi-Stage Cascade v1.0.0</p>
      <p className="mt-1">Turning "Beautiful Crank" into Revolutionary Primitive</p>
      <p className="mt-2 text-purple-300">üíúüå™Ô∏èüòà</p>
    </div>
  </div>
</div>
```

);
};

export default HyperMorphicMultiStageCascade;
