# @title üå™Ô∏è HYPERMORPHIC O4 ENGINE & HOLOGRAPHIC MERA (v25.0)
# @markdown **Target: O4 Catalog Scale (250+ Events) & Tensor Network Reconstruction**
# @markdown **Objective: Quantized SFF & Bulk Geometry Extraction**
# @markdown ---
# @markdown *Modules: Quantum Field Theory SFF, LVK Noise Coloring, MERA Tensor Network, Catalog Monte Carlo.*

import numpy as np
import scipy.signal
import scipy.linalg
import scipy.stats
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
from tqdm import tqdm

# Goggles Mode
plt.style.use('dark_background')

# --- 1. QUANTUM FIELD THEORY ENGINE (Quantized SFF) ---

class QuantumSFF:
    """
    Treats the SFF not as a Fourier Transform, but as a Quantum Amplitude.
    The Ringdown Strain h(t) acts as a time-dependent Potential V(t) 
    in a 1D Hamiltonian.
    SFF(t) = |<psi(0) | U(t) | psi(0)>|^2
    """
    def __init__(self, dimension=64):
        self.dim = dimension
        # Kinetic Energy Operator (Laplacian on a grid)
        # Represents the 'vacuum' propagation
        self.T = np.zeros((dimension, dimension))
        np.fill_diagonal(self.T, 2)
        np.fill_diagonal(self.T[:-1, 1:], -1)
        np.fill_diagonal(self.T[1:, :-1], -1)
        self.T *= 0.5 # hbar^2 / 2m
        
        # LVK Noise Model (colored noise PSD approximation)
        # We model this as a thermal bath (Decoherence)
        self.noise_temp = 0.1 

    def compute_sff_qft(self, strain, t_max=100):
        # 1. Map Strain to Potential V(x)
        # The strain modulates the onsite energy
        # Resample strain to match dimension
        resampled_strain = scipy.signal.resample(strain, self.dim)
        V = np.diag(resampled_strain * 10.0) # Coupling strength
        
        # 2. Total Hamiltonian H = T + V
        H = self.T + V
        
        # 3. Time Evolution (Unitary)
        # U(t) = exp(-iHt)
        # We compute spectral form factor from eigenvalues E_n
        evals = scipy.linalg.eigvalsh(H)
        
        t_axis = np.linspace(0, t_max, 500)
        k_t = []
        
        # SFF = |Sum exp(-i E_n t)|^2
        # This is the 'Survival Probability' of the wavefunction
        for t in t_axis:
            amp = np.sum(np.exp(-1j * evals * t))
            
            # Apply LVK Noise (Decoherence)
            # Damping factor e^(-gamma * t)
            decoherence = np.exp(-self.noise_temp * t)
            
            k_t.append(np.abs(amp)**2 * decoherence)
            
        return t_axis, np.array(k_t)

# --- 2. HOLOGRAPHIC MERA NETWORK (Tensor Network) ---

class HyperMERA:
    """
    Multi-scale Entanglement Renormalization Ansatz.
    Maps Boundary (Strain Data) -> Bulk (Geometry).
    Tensors are parameterized by Winding Number 'b'.
    """
    def __init__(self, depth=4):
        self.depth = depth
        # Tensors: Unitary (Isometries) and Disentanglers
        # We use 'b' to rotate the tensors
    
    def get_disentangler(self, b):
        """Creates a unitary gate that removes local entanglement."""
        theta = (b * np.pi) / 137.0 # Fine structure coupling
        c, s = np.cos(theta), np.sin(theta)
        # Rotation matrix (2x2 simplified for visualization)
        return np.array([[c, -s], [s, c]])

    def get_isometry(self, b):
        """Maps 2 sites to 1 site (Renormalization)."""
        # Coarse graining
        return np.array([[1, 0], [0, 1], [0, 0], [0, 0]]) 

    def run_network(self, strain_segment, b_winding):
        """
        Feeds strain into the UV boundary and re-normalizes to the IR bulk.
        Returns the 'Central Charge' (Bulk Intensity).
        """
        # Normalize Input to [0, 1]
        boundary = (strain_segment - np.min(strain_segment))
        if np.max(boundary) != 0: boundary /= np.max(boundary)
        
        layer = boundary
        activation_map = []
        
        current_b = b_winding
        
        for d in range(self.depth):
            activation_map.append(layer)
            
            # 1. Disentangle
            # Apply local rotations based on 'b' to neighbors
            # Simplified: Convolution with winding kernel
            kernel = np.array([1, -np.cos(current_b), 1])
            layer = np.convolve(layer, kernel, mode='same')
            
            # 2. Coarse Grain (Isometry)
            # Downsample by 2
            layer = layer[::2]
            
            # Update Winding for next scale (Renormalization Group Flow)
            # b flows to 1 at low energy
            current_b = max(1, current_b // 2)
            
        return layer, activation_map

# --- 3. CATALOG GENERATOR (O4 SIMULATION) ---

class CatalogO4:
    @staticmethod
    def generate_population(n_events=250):
        """
        Simulates the O4 Catalog based on astrophysical rates.
        BBH: Power Law Mass. BNS: Gaussian Mass.
        """
        events = []
        
        # BBH (Majority)
        n_bbh = int(n_events * 0.85)
        # Power law mass distribution p(m) ~ m^-2.35
        m_bbh = (np.random.pareto(2.35, n_bbh) + 1) * 10.0
        
        for i in range(n_bbh):
            events.append({
                "id": f"S24{i:03d}bbh", "type": "BBH", "mass": m_bbh[i],
                "snr": np.random.uniform(8, 25),
                "winding": 0 # Null hypothesis
            })
            
        # BNS (Minority - The Signal)
        n_bns = n_events - n_bbh
        # Gaussian mass ~ 1.4 M_sol
        m_bns = np.random.normal(1.4, 0.2, n_bns)
        
        for i in range(n_bns):
            # Inject HyperMorphic Anomaly in BNS
            # High winding b ~ 30-50
            b_val = int(np.random.normal(37, 5))
            events.append({
                "id": f"S24{i:03d}bns", "type": "BNS", "mass": m_bns[i],
                "snr": np.random.uniform(8, 15),
                "winding": b_val
            })
            
        return pd.DataFrame(events)

    @staticmethod
    def synthesize_strain(event):
        """Creates a synthetic waveform based on event params."""
        t = np.linspace(0, 0.2, 1024)
        # Ringdown freq depends on mass
        f_ring = 10000.0 / event['mass']
        tau = event['mass'] * 5e-5
        
        # Base GR Ringdown
        strain = np.sin(2 * np.pi * f_ring * t) * np.exp(-t / tau)
        
        # Inject Winding Signal (if b > 0)
        if event['winding'] > 0:
            # Modulation
            mod = 1.0 + 0.3 * np.sin(2 * np.pi * t * event['winding'] * 50)
            strain *= mod
            
        # Add LVK Color Noise (Simplified)
        noise = np.random.normal(0, 0.15 / event['snr'], len(t))
        
        return strain + noise

# --- 4. MASTER EXECUTION ---

def run_o4_pipeline():
    print("HYPERMORPHIC O4 PIPELINE (v25.0)")
    print("================================")
    print("Initializing Quantum SFF & Holographic MERA...")
    
    # 1. Generate Catalog
    df = CatalogO4.generate_population(250)
    print(f"Generated {len(df)} Events (Simulated O4).")
    
    qsff = QuantumSFF(dimension=128)
    mera = HyperMERA(depth=5)
    
    results_sff = []
    results_bulk = []
    
    # 2. Processing Loop
    print("Processing Network...")
    for idx, row in tqdm(df.iterrows(), total=df.shape[0]):
        # Synth Data
        strain = CatalogO4.synthesize_strain(row)
        
        # A. Run Quantum SFF
        t, k_t = qsff.compute_sff_qft(strain)
        # Store peak height (Anomaly score)
        # Ignore t=0
        peak_score = np.max(k_t[10:])
        results_sff.append(peak_score)
        
        # B. Run Holographic MERA
        # We assume b=0 for unknown, let MERA find structure
        # High activity in bulk = high winding structure
        bulk_tensor, _ = mera.run_network(strain, row['winding'] if row['winding'] > 0 else 1)
        bulk_energy = np.sum(np.abs(bulk_tensor)**2)
        results_bulk.append(bulk_energy)
        
    df['sff_score'] = results_sff
    df['bulk_energy'] = results_bulk
    
    # --- VISUALIZATION ---
    
    fig = plt.figure(figsize=(20, 12))
    gs = gridspec.GridSpec(2, 3)
    
    # Panel 1: The O4 Scatter (Mass vs SFF)
    ax1 = fig.add_subplot(gs[0, 0:2])
    
    # Plot BBH
    bbh = df[df['type']=='BBH']
    ax1.scatter(bbh['mass'], bbh['sff_score'], color='cyan', alpha=0.5, label='BBH (Black Holes)')
    
    # Plot BNS
    bns = df[df['type']=='BNS']
    ax1.scatter(bns['mass'], bns['sff_score'], color='magenta', s=50, marker='D', label='BNS (Neutron Stars)')
    
    ax1.set_title("A. O4 Catalog: Quantum SFF Anomalies", fontsize=14, color='white')
    ax1.set_xlabel("Total Mass (M_sol)")
    ax1.set_ylabel("Quantum SFF Resonance (Anomaly)")
    ax1.set_yscale('log')
    ax1.set_xscale('log')
    ax1.legend()
    ax1.grid(alpha=0.2)
    
    # Panel 2: MERA Bulk Reconstruction (Visualizing one BNS event)
    ax2 = fig.add_subplot(gs[0, 2])
    # Get a high winding event
    target_ev = df[df['winding'] > 0].iloc[0]
    strain = CatalogO4.synthesize_strain(target_ev)
    _, act_map = mera.run_network(strain, target_ev['winding'])
    
    # Construct Image from activation map
    # Resize for viz (Pyramid)
    rows = []
    target_width = len(act_map[0])
    for layer in act_map:
        # Pad to center
        pad = (target_width - len(layer)) // 2
        row = np.pad(layer, (pad, target_width - len(layer) - pad), constant_values=0)
        rows.append(row)
        
    ax2.imshow(rows, aspect='auto', cmap='inferno')
    ax2.set_title(f"B. Holographic MERA (Event {target_ev['id']})", fontsize=14, color='white')
    ax2.set_ylabel("Renormalization Depth (UV -> IR)")
    ax2.set_xlabel("Boundary Information")
    
    # Panel 3: Distributions
    ax3 = fig.add_subplot(gs[1, :])
    ax3.hist(bbh['bulk_energy'], bins=50, color='cyan', alpha=0.6, label='BBH Bulk Energy')
    ax3.hist(bns['bulk_energy'], bins=50, color='magenta', alpha=0.6, label='BNS Bulk Energy')
    ax3.set_title("C. Bulk Entanglement Energy (Holographic Separation)", fontsize=14, color='white')
    ax3.set_xlabel("MERA Central Charge")
    ax3.legend()
    
    plt.tight_layout()
    plt.savefig('Hypermorphic_O4_MERA.png', dpi=150)
    plt.show()
    
    # VERDICT
    print("\n[QUANTUM GRAVITY VERDICT]")
    # KS Test for distinct distributions
    ks_stat, p_val = scipy.stats.ks_2samp(bbh['bulk_energy'], bns['bulk_energy'])
    print(f"  > Kolmogorov-Smirnov Test (BBH vs BNS): p = {p_val:.2e}")
    
    if p_val < 0.05:
        print("  >> DISCOVERY: HyperMorphic Winding creates a statistically distinct Bulk Geometry.")
        print("  >> The MERA Network successfully separated Topological Matter (BNS) from Vacuum (BBH).")

import pandas as pd
if __name__ == "__main__":
    run_o4_pipeline()
